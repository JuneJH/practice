<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>异步处理</title>
</head>
<body>
    

    <script src="./MyPromise.js"></script>r

    <script>

const p = new MyPromise((resolve,reject)=>{
    console.log("runnnn myPromise");
    setTimeout(()=>{
        resolve("成功处理");
    },3000)
})

p.then(res=>{
    return new MyPromise(resolve=>{
        console.log("res0",res)
        setTimeout(()=>{
            resolve(123)
        },3000)
    })
}).then(res=>{
    console.log("res1",res)
})
// p.then(res=>{
//     console.log("res1",res)
// })
// p.then(res=>{
//     console.log("res2",res)
// })
// p.then(res=>{
//     console.log("res3",res)
// })
// p.then(res=>{
//     console.log("res4",res)
// })
// p.catch(err=>{
//     console.log("err")
// })

console.log(p)

// Promise 状态

// 1. Pendding
// 2. Fulfilled
// 3. Rejected

// 解决回调地狱和事件

// const  p = new Promise((resolve,reject)=>{
//     console.log("run Prmise");
//     setTimeout(()=>{
//         console.log("runnn")
//         resolve("ok")
//     })
// })

// console.log(p)

// const p = new Promise((resolve, reject) => {
//     console.log('初始化');

//     // reject("错误");
//     resolve("111")
// })
// .then(() => {
//     const r = Math.random() ;

//     if(r > 0.5 ){
//         throw new Error('有哪里不对了')
//     }

//     console.log('1.then');
//     return "1.then params"
// })

// .then((res) => {
//     console.log('2.then',res);
//     return 123
// })
// // 通常，一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 onRejected 失败回调函数或者由 .catch() 指定的回调函数。
// .catch((err) => {
//     console.log('catch',err);
//     return "err"
// })


function func1(){console.log("fn 1");return 1}
function func2(res){return new Promise((resolve,reject)=>{setTimeout(()=>{console.log("fn 2",res);reject(2)},2000)})}
function func3(res){console.log("fn 3",res);return 3}
function func4(){console.log("fn 4");return 4}

// 并行,所有处理完毕执行then
// Promise.all([func1(), func2(), func3()])
// .then(([result1, result2, result3]) => {console.log("res ",result1,result2,result3)});

// Promise.race([func2()]).then(res=>{
//     console.log("res",res)
// })

// // 时序执行
// // [func1, func2, func3].reduce((p, f) => p.then(f), Promise.resolve())
// // .then(result3 => { console.log(result3) });

// // 执行顺序
// const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

// wait().then(() => console.log(4));
// Promise.resolve().then(() => console.log(2)).then(() => console.log(3));
// console.log(1); // 1, 2, 3, 4


    </script>
</body>
</html>